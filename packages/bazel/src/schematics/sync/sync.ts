import { join, normalize } from '@angular-devkit/core';
import {
  apply,
  chain,
  MergeStrategy,
  mergeWith,
  move,
  Rule,
  SchematicContext,
  Source,
  template,
  Tree,
  url
} from '@angular-devkit/schematics';
import { NodePackageInstallTask } from '@angular-devkit/schematics/tasks';
import {
  DependencyGraph,
  getDependencyGraphFromTree,
  ProjectNode,
  readJsonInTree,
  updateJsonInTree
} from '@nrwl/workspace';
const ignore = require('ignore');

function createBuildFile(
  project: ProjectNode,
  depGraph: DependencyGraph
): Source {
  return apply(url('./files/build-file'), [
    template({ tmpl: '', project, depGraph })
  ]);
}

function updateBuildFile(
  project: ProjectNode,
  depGraph: DependencyGraph
): Rule {
  return (host, _context) => {
    const buildFile = createBuildFile(project, depGraph);
    const buildFilePath = join(normalize(project.root), 'BUILD.bazel');

    return mergeWith(
      apply(buildFile, [
        sourceHost => {
          if (host.exists(buildFilePath)) {
            const contents = sourceHost.read('BUILD.bazel').toString();
            const customPart = host
              .read(buildFilePath)
              .toString()
              .split('# ==== Generated by Nx')[0];
            host.delete(buildFilePath);
            sourceHost.overwrite('BUILD.bazel', customPart + contents);
          }
        },
        move(project.root)
      ]),
      MergeStrategy.Overwrite
    );
  };
}

function createRootFiles(): Rule {
  return host => {
    return mergeWith(
      apply(url('./files/root'), [
        template({
          tmpl: '',
          rootFiles: host
            .getDir('/')
            .subfiles.filter(f => f !== 'WORKSPACE' && f !== 'BUILD.bazel'),
          name: readJsonInTree(host, '/package.json').name.replace('-', '_')
        }),
        () => {
          if (host.exists('WORKSPACE')) {
            host.delete('WORKSPACE');
          }
          if (host.exists('.bazelrc')) {
            host.delete('.bazelrc');
          }
          if (host.exists('nx.bzl')) {
            host.delete('nx.bzl');
          }
          if (host.exists('BUILD.bazel')) {
            host.delete('BUILD.bazel');
          }
        }
      ]),
      MergeStrategy.Overwrite
    );
  };
}

function addNpmPackagePatches(): Rule {
  return host => {
    return mergeWith(
      apply(url('./files/patches'), [
        template({
          tmpl: '',
          rootFiles: host
            .getDir('/')
            .subfiles.filter(f => f !== 'WORKSPACE' && f !== 'BUILD.bazel'),
          name: readJsonInTree(host, '/package.json').name.replace('-', '_')
        }),
        () => {
          if (host.exists('patches')) {
            host.delete('patches');
          }
        }
      ]),
      MergeStrategy.Overwrite
    );
  };
}

function addRequiredPackages() {
  const devDeps = {
    'patch-package': '^6.2.0',
    '@bazel/bazel': '^1.2.0',
    '@bazel/ibazel': '0.10.3'
  };

  return updateJsonInTree('package.json', (json, context: SchematicContext) => {
    if (!json.scripts) {
      json.scripts = {};
    }
    if (json.scripts.postinstall) {
      if (!(json.scripts.postinstall as string).includes('patch-package')) {
        json.scripts.postinstall = `patch-package && ${json.script.postinstall}`;
      }
    } else {
      json.scripts.postinstall = 'patch-package';
    }

    Object.keys(devDeps).forEach(key => {
      if (json.dependencies) {
        delete json.dependencies[key];
      }
      if (json.devDependencies) {
        delete json.devDependencies[key];
      }
    });

    json.devDependencies = {
      ...(json.devDependencies || {}),
      ...devDeps
    };

    context.addTask(new NodePackageInstallTask());

    return json;
  });
}

function updateGitIgnore(): Rule {
  return host => {
    if (!host.exists('.gitignore')) {
      return;
    }

    const ig = ignore();
    ig.add(host.read('.gitignore').toString());

    if (!ig.ignores('bazel-out')) {
      const content = `${host
        .read('.gitignore')!
        .toString('utf-8')
        .trimRight()}\nbazel-*\n`;
      host.overwrite('.gitignore', content);
    }
  };
}

export default (): Rule => {
  return (host: Tree) => {
    const depGraph = getDependencyGraphFromTree(host);

    return chain([
      createRootFiles(),
      addNpmPackagePatches(),
      addRequiredPackages(),
      updateGitIgnore(),
      ...Object.values(depGraph.projects).map(project =>
        updateBuildFile(project, depGraph)
      )
    ]);
  };
};
