import { Token, TokenType, lexBuildFile } from './lexer';

export interface BuildTarget {
  targetStart: number;
  targetEnd: number;
  name: string;
}

export interface BuildFile {
  generatedCodeStart?: number;
  generatedCodeEnd?: number;
  buildTargets: Array<BuildTarget>;
  content: string;
}

export function parseBuildFile(fileContent: string): BuildFile {
  const tokens = lexBuildFile(fileContent);
  const buildTargets: Array<BuildTarget> = [];

  let currentTargetStart: Token | undefined;
  let currentTargetName: string | undefined;
  let generatedCodeStart: Token | undefined;
  let generatedCodeEnd: Token | undefined;

  let index = -1;
  while (index < tokens.length - 1) {
    index++;
    const token = tokens[index];
    switch (token.tokenType) {
      case TokenType.PROPERTY_NAME:
        const propertyName = fileContent.slice(
          token.startPosition,
          token.endPosition
        );
        if (propertyName === 'name') {
          const assignmentToken = tokens[index + 1];
          const nameToken = tokens[index + 2];

          if (
            assignmentToken.tokenType !== TokenType.ASSIGNMENT ||
            nameToken.tokenType !== TokenType.STRING
          ) {
            throw new Error(
              'Parse error. Name property was not followed by string value'
            );
          }

          currentTargetName = stripQuotesFromString(
            fileContent.slice(nameToken.startPosition, nameToken.endPosition)
          );
        }
        break;
      case TokenType.TARGET_START:
        if (currentTargetStart) {
          throw new Error('Target was started inside another target');
        }
        currentTargetStart = token;
        break;
      case TokenType.TARGET_END:
        if (!currentTargetStart) {
          throw new Error('Target was ended but had no start');
        }
        buildTargets.push({
          name: currentTargetName,
          targetEnd: token.endPosition,
          targetStart: currentTargetStart.startPosition
        });
        currentTargetStart = undefined;
        break;
      case TokenType.COMMENT:
        const content = fileContent.slice(
          token.startPosition,
          token.endPosition
        );
        if (content === '# ==== Generated by Nx') {
          generatedCodeStart = token;
        } else if (content === '# ==== End NX generated content') {
          generatedCodeEnd = token;
        }
        break;
    }
  }

  return {
    buildTargets,
    content: fileContent,
    generatedCodeEnd: generatedCodeEnd
      ? generatedCodeEnd.endPosition
      : generatedCodeStart
      ? generatedCodeStart.endPosition
      : undefined,
    generatedCodeStart: generatedCodeStart
      ? generatedCodeStart.startPosition
      : generatedCodeEnd
      ? generatedCodeEnd.startPosition
      : undefined
  };
}

function stripQuotesFromString(string: String) {
  if (string.startsWith(`"""`) || string.startsWith(`'''`)) {
    return string.slice(3, -3);
  }

  return string.slice(1, -1);
}
