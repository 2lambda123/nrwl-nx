import { parseSyml, stringifySyml } from '@yarnpkg/parsers';
import { stringify } from '@yarnpkg/lockfile';
import {
  LockFileData,
  PackageDependency,
  PackageVersions,
} from './lock-file-type';
import { satisfies } from 'semver';
import { sortObject } from './utils';

type YarnLockFile = Record<string, Omit<PackageDependency, 'packageMeta'>>;

/**
 * Parses yarn.lock syml file and maps to `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
export function parseYarnLockFile(lockFile: string): LockFileData {
  const { __metadata, ...dependencies } = parseSyml(lockFile);
  const [mappedPackages, workspacePackages] = mapPackages(dependencies);
  const isBerry = !!__metadata;
  if (isBerry) {
    return {
      dependencies: mappedPackages,
      lockFileMetadata: {
        __metadata,
        workspacePackages,
      },
    };
  } else {
    return { dependencies: mappedPackages };
  }
}

function mapPackages(
  packages: YarnLockFile
): [LockFileData['dependencies'], YarnLockFile] {
  const mappedPackages: LockFileData['dependencies'] = {};
  const workspacePackages: YarnLockFile = {};

  Object.entries(packages).forEach(([keyExpr, value]) => {
    // for berry, ignore workspace packages.
    // we only care about those when pruning
    if (value.linkType === 'soft') {
      workspacePackages[keyExpr] = value;
    } else {
      const keys = keyExpr.split(', ');
      const packageName = keys[0].slice(0, keys[0].lastIndexOf('@'));
      mappedPackages[packageName] = mappedPackages[packageName] || {};

      const newKey = `${packageName}@${value.version}`;
      mappedPackages[packageName][newKey] =
        mappedPackages[packageName][newKey] ||
        ({
          ...value,
          packageMeta: [],
        } as PackageDependency);
      mappedPackages[packageName][newKey].packageMeta.push(...keys);
    }
  });
  return [mappedPackages, workspacePackages];
}

/**
 * Generates yarn.lock file from `LockFileData` object
 *
 * @param lockFileData
 * @returns
 */
export function stringifyYarnLockFile(lockFileData: LockFileData): string {
  const isBerry = !!lockFileData.lockFileMetadata?.__metadata;
  if (isBerry) {
    const lockFile = {
      __metadata: lockFileData.lockFileMetadata.__metadata,
      ...lockFileData.lockFileMetadata.workspacePackages,
      ...unmapPackages(lockFileData.dependencies, isBerry),
    };
    return (
      `# This file was generated by Nx. Do not edit this file directly\n# Manual changes might be lost - proceed with caution!\n\n` +
      stringifySyml(lockFile)
    );
  } else {
    return stringify(unmapPackages(lockFileData.dependencies));
  }
}

function unmapPackages(
  mappedPackages: YarnLockFile,
  isBerry = false
): YarnLockFile {
  const packages: YarnLockFile = {};
  Object.values(mappedPackages).forEach((versions) => {
    Object.values(versions).forEach((value) => {
      const { packageMeta, ...rest } = value;
      if (isBerry) {
        packages[packageMeta.join(', ')] = rest;
      } else {
        packageMeta.forEach((key) => {
          packages[key] = rest;
        });
      }
    });
  });
  return packages;
}

/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
export function pruneYarnLockFile(
  lockFileData: LockFileData,
  packages: string[]
): LockFileData {
  const cleanDependencies: LockFileData['dependencies'] = {};

  packages.forEach((packageName) => {
    if (lockFileData.dependencies[packageName]) {
      cleanDependencies[packageName] = cleanDependencies[packageName] || {};
      // take the first version of the package as the default
      const [key, value] = Object.entries(
        lockFileData.dependencies[packageName]
      )[0];
      cleanDependencies[packageName][key] = value;
      addTransitiveDependencies(
        lockFileData.dependencies,
        cleanDependencies,
        value
      );
    } else {
      console.warn(
        `Could not find ${packageName} in the lock file. Skipping...`
      );
    }
  });

  const isBerry = !!lockFileData.lockFileMetadata?.__metadata;
  if (isBerry) {
    return {
      lockFileMetadata: {
        __metadata: lockFileData.lockFileMetadata.__metadata,
        workspacePackages: pruneWorkspacePackages(
          lockFileData.lockFileMetadata.workspacePackages,
          cleanDependencies,
          packages
        ),
      },
      dependencies: cleanDependencies,
    };
  } else {
    return { dependencies: cleanDependencies };
  }
}

function pruneWorkspacePackages(
  workspacePackages: YarnLockFile,
  cleanDependencies: LockFileData['dependencies'],
  packages: string[]
): YarnLockFile {
  const prunedPackages: YarnLockFile = {};
  let rootWorkspacePackage;

  Object.entries(workspacePackages).forEach(
    ([key, { dependencies, ...value }]) => {
      const prunedDependencies: Record<string, string> = {};
      Object.entries(dependencies).forEach(
        ([packageName, packageVersion]: [string, string]) => {
          if (
            cleanDependencies[packageName] &&
            Object.values(cleanDependencies[packageName]).some(
              (packageDep) =>
                packageDep.packageMeta.indexOf(
                  `${packageName}@${packageVersion}`
                ) !== -1 ||
                packageDep.packageMeta.indexOf(
                  `${packageName}@npm:${packageVersion}`
                ) !== -1
            )
          ) {
            prunedDependencies[packageName] = packageVersion;
          }
        }
      );
      // add all missing deps for root package
      if (key.indexOf('@workspace:.') !== -1) {
        packages.forEach((p) => {
          if (!prunedDependencies[p]) {
            const metaVersion = Object.values(cleanDependencies[p])[0]
              .packageMeta[0] as string;
            prunedDependencies[p] = metaVersion.split('@npm:')[1];
          }
        });
      }
      prunedPackages[key] = {
        ...value,
        dependencies: sortObject(prunedDependencies),
      };
    }
  );

  return prunedPackages;
}

function addTransitiveDependencies(
  dependencies: LockFileData['dependencies'],
  cleanDependencies: LockFileData['dependencies'],
  value: PackageDependency
): void {
  Object.entries(value.dependencies || {}).forEach(([depName, depVersion]) => {
    if (dependencies[depName]) {
      const dependencyTriplet = findDependencyTriplet(
        dependencies[depName],
        depName,
        depVersion
      );
      if (dependencyTriplet) {
        const [depKey, { packageMeta, ...value }, metaVersion] =
          dependencyTriplet;
        cleanDependencies[depName] = cleanDependencies[depName] || {};
        if (!cleanDependencies[depName][depKey]) {
          cleanDependencies[depName][depKey] = {
            ...value,
            packageMeta: [metaVersion],
          };
          addTransitiveDependencies(
            dependencies,
            cleanDependencies,
            cleanDependencies[depName][depKey]
          );
        } else {
          if (
            cleanDependencies[depName][depKey].packageMeta.indexOf(
              metaVersion
            ) === -1
          ) {
            cleanDependencies[depName][depKey].packageMeta = [
              ...cleanDependencies[depName][depKey].packageMeta,
              metaVersion,
            ].sort();
          }
        }
      }
    }
  });
}

function findDependencyTriplet(
  version: PackageVersions,
  depName: string,
  depVersion: string
): [string, PackageDependency, string] {
  const entries = Object.entries(version);
  for (let i = 0; i < entries.length; i++) {
    const [depKey, depValue] = entries[i];
    let packageMeta = `${depName}@${depVersion}`;
    if (depValue.packageMeta.includes(packageMeta)) {
      return [depKey, depValue, packageMeta];
    }
    // for berry, meta version starts with 'npm:'
    packageMeta = `${depName}@npm:${depVersion}`;
    if (depValue.packageMeta.includes(packageMeta)) {
      return [depKey, depValue, packageMeta];
    }
  }
  return;
}
